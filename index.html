<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0"/>

        <title>3D Image Slider</title>
        <link rel="stylesheet" href="styles.css"/>
    </head>

    <body>
        <nav>
            <div class="nav-items">
                <a href="#">Visions</a>
                <a href="#">Perspectives</a>
            </div>
            <div class="logo">
                <a href="#">Focal Point</a>
            </div>
            <div class="nav-items">
                <a href="#">Insight</a>
                <a href="#">Collaborate</a>
            </div>
        </nav>
        <footer>
            <p>Sharpen Your Focus</p>
            <p>Reframing Perspectives Since 2024</p>
        </footer>

        <div class="loader">
            <div class="loader-content">
                <p>Loading...</p>
                <div class="progress">
                    <div class="progress-bar"></div>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="overlay"></div>
            <div class="slider"></div>
        </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
        <script src="https://unpkg.com/lenis@1.1.13/dist/lenis.min.js"></script>
        <script id="vertexShader" type="x-shader/x-vertex">
            void main() {  
                gl_Position = vec4(position, 1.0);
            }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
            uniform vec2 iResolution;
            uniform float iTime;
            uniform sampler2D iChannel0;
            uniform sampler2D iChannel1;
            uniform float scrollOffset;

            #define PI 3.1415926535898
            #define FH 1.0
            #define BASE_SPEED 3.0
            #define MAX_SPEED 12.0

            float getGrey(vec3 p){ 
                return p.x*0.299 + p.y*0.587 + p.z*0.114; 
            }

            vec3 hash33(vec3 p){ 
                float n = sin(dot(p, vec3(7, 157, 113)));    
                return fract(vec3(2097152, 262144, 32768)*n); 
            }

            mat2 rot2(float a){
                float c = cos(a); 
                float s = sin(a);
                return mat2(c, s, -s, c);
            }

            vec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){
                n = max((abs(n) - 0.2)*7., 0.001);
                n /= (n.x + n.y + n.z );  
                return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;
            }

            vec3 tri(in vec3 x){
                return abs(x-floor(x)-.5);
            }

            float surfFunc(in vec3 p){
                return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));
            }

            vec2 path(in float z){ 
                float s = sin(z/24.)*cos(z/12.); 
                return vec2(s*5.0, 0.);
            }

            float map(vec3 p){
                float sf = surfFunc(p - vec3(0, cos(p.z/3.)*.15, 0));
                vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);
                float n = 1. - max(tun.x, tun.y) + (0.5 - sf);
                return min(n, p.y + FH);
            }

            vec3 getNormal(in vec3 p) {
                const float eps = 0.001;
                return normalize(vec3(
                    map(vec3(p.x + eps, p.y, p.z)) - map(vec3(p.x - eps, p.y, p.z)),
                    map(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),
                    map(vec3(p.x, p.y, p.z + eps)) - map(vec3(p.x, p.y, p.z - eps))
                ));
            }

            float calculateAO(vec3 p, vec3 n){
                const float AO_SAMPLES = 5.0;
                float r = 0.0, w = 1.0, d;
                
                for (float i = 1.0; i<AO_SAMPLES + 1.1; i++){
                    d = i/AO_SAMPLES;
                    r += w*(d - map(p + n*d));
                    w *= 0.5;
                }
                
                return 1.0 - clamp(r, 0.0, 1.0);
            }

            float curve(in vec3 p, in float w){
                vec2 e = vec2(-1., 1.)*w;
                
                float t1 = map(p + e.yxx), t2 = map(p + e.xxy);
                float t3 = map(p + e.xyx), t4 = map(p + e.yyy);
                
                return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord){
                vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;
                
                float scrollSpeed = BASE_SPEED + (clamp(scrollOffset, 0.0, 1.0) * (MAX_SPEED - BASE_SPEED));
                
                vec3 camPos = vec3(0.0, 0.0, iTime * scrollSpeed);
                float lookAheadDist = 0.5 + (clamp(scrollOffset, 0.0, 1.0) * 0.3);
                vec3 lookAt = camPos + vec3(0.0, 0.1, lookAheadDist);

                vec3 light_pos = camPos + vec3(0.0, 0.125, -0.125);
                vec3 light_pos2 = camPos + vec3(0.0, 0.0, 6.0);

                float scrollFactor = 1.0 + (clamp(scrollOffset, 0.0, 1.0) * 0.5);
                
                vec2 camPath = path(camPos.z);
                vec2 lookPath = path(lookAt.z);
                
                lookAt.xy += lookPath * 0.8;
                camPos.xy += camPath * 0.8;
                
                light_pos.xy += camPath * 0.8;
                light_pos2.xy += camPath * 0.8;

                float FOV = PI/3.;
                vec3 forward = normalize(lookAt-camPos);
                vec3 right = normalize(vec3(forward.z, 0., -forward.x)); 
                vec3 up = cross(forward, right);

                vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);
                
                float rotationIntensity = path(lookAt.z).x/48. * (1.0 + (clamp(scrollOffset, 0.0, 1.0) * 0.3));
                rd.xy = rot2(rotationIntensity)*rd.xy;
                    
                float t = 0.0, dt;
                for(int i=0; i<128; i++){
                    dt = map(camPos + rd*t);
                    if(dt<0.005 || t>150.){ break; } 
                    t += dt*0.75;
                }
                
                vec3 sceneCol = vec3(0.);
                
                if(dt<0.005){
                    vec3 sp = t * rd+camPos;
                    vec3 sn = getNormal(sp);
                    
                    const float tSize0 = 1./1.; 
                    const float tSize1 = 1./4.;
                    
                    float ao = calculateAO(sp, sn);
                    
                    vec3 ld = light_pos-sp;
                    vec3 ld2 = light_pos2-sp;

                    float distlpsp = max(length(ld), 0.001);
                    float distlpsp2 = max(length(ld2), 0.001);
                    
                    ld /= distlpsp;
                    ld2 /= distlpsp2;
                    
                    float atten = min(1./(distlpsp) + 1./(distlpsp2), 1.);
                    
                    float ambience = 0.25;
                    
                    float diff = max(dot(sn, ld), 0.0);
                    float diff2 = max(dot(sn, ld2), 0.0);
                    
                    float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.0), 8.);
                    float spec2 = pow(max(dot(reflect(-ld2, sn), -rd), 0.0), 8.);
                    
                    float crv = clamp(curve(sp, 0.125)*0.5 + 0.5, .0, 1.);
                    
                    float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 1.);
                    
                    vec3 texCol;
                    if (sp.y<-(FH - 0.005)) texCol = tex3D(iChannel1, sp*tSize1, sn);
                    else texCol = tex3D(iChannel0, sp*tSize0, sn);
                
                    float shading = crv*0.5 + 0.5; 
                    
                    sceneCol = getGrey(texCol)*((diff + diff2)*0.75 + ambience*0.25) + 
                            (spec + spec2)*texCol*2. + fre*crv*texCol.zyx*2.;
                    
                    sceneCol *= atten*shading*ao;
                    
                    sceneCol *= clamp(1.-abs(curve(sp, 0.0125)), .0, 1.);        
                }
                
                fragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        </script>

        <script type="module">
            import { slides } from "./data.js";


const lenis = new Lenis();
lenis.on("scroll", ScrollTrigger.update);
gsap.ticker.add((time) => {
    lenis.raf(time * 1000);
});
gsap.ticker.lagSmoothing(0);


const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);


const geometry = new THREE.PlaneGeometry(2, 2);


const loader = new THREE.TextureLoader();
const texture0 = loader.load('1.jpeg', function(texture) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.minFilter = THREE.LinearMipmapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = true;
    texture.flipY = true;
});

const texture1 = loader.load('2.jpeg', function(texture) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.minFilter = THREE.LinearMipmapLinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = true;
});


const uniforms = {
    iTime: { value: 0 },
    iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    iChannel0: { value: texture0 },
    iChannel1: { value: texture1 },
    scrollOffset: { value: 0 }
};


const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: document.getElementById("vertexShader").textContent,
    fragmentShader: document.getElementById("fragmentShader").textContent,
});


const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);


let baseTime = 0;
const BASE_SPEED = 0.001;


class ImagePreloader {
    constructor(totalImages) {
        this.totalImages = totalImages;
        this.loadedImages = 0;
        this.images = new Map();
        this.progressBar = document.querySelector('.progress-bar');
        this.loader = document.querySelector('.loader');
    }

    async preloadImages() {
        const imagePromises = [];

        for(let i = 1; i <= this.totalImages; i++) {
            imagePromises.push(this.loadImage(`./assets/img${i}.jpeg`, i));
        }

        try {
            await Promise.all(imagePromises);
            this.loader.style.display = 'none';
            return this.images;
        } catch (error) {
            console.error('Error preloading images:', error);
            this.loader.innerHTML = 'Error loading images. Please refresh the page.';
        }
    }

    loadImage(src, index) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            
            img.onload = () => {
                this.loadedImages++;
                this.updateProgress();
                this.images.set(index, img);
                resolve(img);
            };

            img.onerror = () => {
                reject(new Error(`Failed to load image: ${src}`));
            };

            img.src = src;
        });
    }

    updateProgress() {
        const progress = (this.loadedImages / this.totalImages) * 100;
        this.progressBar.style.width = `${progress}%`;
    }
}


function animate() {
    baseTime += BASE_SPEED;
    uniforms.iTime.value = baseTime + uniforms.scrollOffset.value * 10;
    
    const currentSpeed = BASE_SPEED + (uniforms.scrollOffset.value * (12.0 - 3.0));
    
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}


animate();


const totalSlides = 10;
const zStep = 2500;
const initialZ = -22500;


const imagePreloader = new ImagePreloader(totalSlides);


async function generateSlides() {
    const preloadedImages = await imagePreloader.preloadImages();
    const slider = document.querySelector(".slider");
    slider.innerHTML = "";

    for(let i = 1; i <= totalSlides; i++) {
        const slide = document.createElement("div");
        slide.className = "slide";
        slide.id = `slide-${i}`;

        const slideImg = document.createElement("div");
        slideImg.className = "slide-img";

        
        const img = preloadedImages.get(i).cloneNode();
        img.loading = "lazy";

        const slideCopy = document.createElement("div");
        slideCopy.className = "slide-copy";
        slideCopy.innerHTML = `
            <p>${slides[i - 1].title}</p>
            <p>${slides[i - 1].id}</p>
        `;

        slideImg.appendChild(img);
        slide.appendChild(slideImg);
        slide.appendChild(slideCopy);
        slider.appendChild(slide);

        const zPosition = initialZ + (i - 1) * zStep;
        const xPosition = i % 2 === 0 ? "30%" : "70%";
        const opacity = i === totalSlides ? 1 : 
                       i === totalSlides - 1 ? 0 : 0;

        gsap.set(slide, {
            top: "50%",
            left: xPosition,
            xPercent: -50,
            yPercent: -50,
            z: zPosition,
            opacity: opacity,
        });
    }

    initializeAnimations();
}


function initializeAnimations() {
    const slides = gsap.utils.toArray(".slide");

    function getInitialTranslateZ(slide) {
        return gsap.getProperty(slide, "z");
    }

    function mapRange(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }

    
    const containerTrigger = ScrollTrigger.create({
        trigger: ".container",
        start: "top top",
        end: "bottom bottom",
        scrub: 1,
        onUpdate: (self) => {
            uniforms.scrollOffset.value = self.progress;
        },
    });

   
    function resetScrollPosition() {
        window.scrollTo(0, 0);
        containerTrigger.scroll(0);
        containerTrigger.refresh();
    }

    resetScrollPosition();

   
    slides.forEach((slide, index) => {
        const initialZ = getInitialTranslateZ(slide);

        ScrollTrigger.create({
            trigger: ".container",
            start: "top top",
            end: "bottom bottom",
            scrub: 1,
            onUpdate: (self) => {
                const progress = self.progress;
                const zIncrement = progress * 22500;
                const currentZ = initialZ + zIncrement;

                let opacity;
                if (currentZ >= -2500) {
                    opacity = mapRange(currentZ, -2500, 0, 0, 1);
                } else {
                    opacity = mapRange(currentZ, -5000, -2500, 0, 0);
                }

                slide.style.opacity = opacity;
                slide.style.transform = `translateX(-50%) translateY(-50%) translateZ(${currentZ}px)`;
            },
        });
    });
}


window.addEventListener("load", function() {
    generateSlides();
});

window.addEventListener("resize", () => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    renderer.setSize(width, height);
    uniforms.iResolution.value.set(width, height);
});

window.addEventListener('beforeunload', function() {
    window.scrollTo(0, 0);
});
        </script>
    </body>
</html>